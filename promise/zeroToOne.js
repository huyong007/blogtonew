/* # 从零到一：很纯的函数式  
## 从干活的角度看待函数式编程和一般的编程方法
- 函数`` addOne ``是一个函数式编程的写法
- 函数``add``是一般写法
 */
```javascript

function addOne(x) {
    return function (y) {
        return x + y;
    }
};

 addOne(2)(1);
var x = 1 ;var y = 2;
function add(x, y) {
    return x + y;
}
add(1,2);
```
/* # 两者的优缺点：
- ``addOne``不用考虑作用域的问题，函数内部的变量不会受到外部的影响
- ``addOne``还能进行再创造，而``add``函数看似很简单但是写了之后成了一次性的了，比如：
 */
```js
var inc = addOne(1);
inc(2);
```

/*   - 此时函数``inc();``就变成了给所有参数自己增加一的一个新函数，而我们往常的写法是 */

```
function addTwo(y){
    return y + 1;
}
```
/* 
- 这样写了之后我们就没法在其他地方复用，可能是以下原因：
  - 这个``y``可能会继承了某种属性，移植到其他地方执行不起来
  - 作用域会发生改变
  - 可能还有其他原因，如此这般我们的精力就分配到了关注很多地方，降低了生产率，变相减少了寿命。
- 再看下面这两个函数 */

```
var num = 1;
function addThree(x){
    return x + num ;
}

function addFour(x){
    var num = 1;
    return x + num ;
}
```
/* - 这两个函数第一个就不是函数式编程，第二个是，函数内部不受外界的任何影响，这也是函数从零到一开始学习的可能最重要的一个特点：
  - 函数本身是不是纯洁、透明，不受外界影响的，可以移植的（老师说道还有其他很多特点，就慢慢探索了）。

# 从一到二：定义过程
- 看下面这个函数 */

```
function addFive(x){
    return x + 1 ;
}
function addSix(y){
    return y + 2 ;
}

function ADD(f,g){
    return function(x){
        return f(g(x));
    }
}
ADD(addFive,addSix)(3);
```
/* - 我们把``(3+2)+1=6``,整个过程通过函数式实现了出来，使用一个函数把两个函数联合起来一步接着一步的处理参数得到我们想要的结果;
- 如果我们把整个函数想象成一个APP项目得到一个请求``request``，首先进入中间件**“addSix”**得到一个结果**“5”**，
- 然后再把整个结果给到**“addFive”**这个中间件处理最终给出响应**“response--“6””**，
-我们把数据在函数这个类似一截管道中流转的过程就定义了，只需要关注数据的进和出就可以了;
- 以上 就是我对于老师在进阶课第八课和第九课函数式入门课的总结; */